# 12-13장 컴포넌트 응집도

해당 파트는 클래스와 모듈을 단일 컴포넌트로 묶는 방법에 대해 설명하고자 한다.

### 컴포넌트 응집도와 관련된 세가지 원칙

- REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)
- CCP: 공통 폐쇄 원칙 (Common Closure Principle)
- CRP: 공통 재사용 원칙 (Common Reuse Principle)
  <br />
  <br />

## 💡<strong>REP: 재사용/릴리스 등가 원칙</strong>

👉 재사용 단위는 릴리스 단위와 같다.
<br />
<br />
새로운 릴리스가 나온다는 소식을 접하면, 개발자는 새 릴리스의 변경사항을 살펴보고 기존 버전을 계속 쓸지 여부를 결정하곤 한다.<br />
따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다.
<br />
<br />
이런 관점에서 보면 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.
<br />
<br />
<strong>`컴포넌트를 재사용` 할 수 있고, `재사용 컴포넌트들이 서로 호환`되는지 알기 위해서는</strong>

1. 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다.
2. 버전 번호가 같아야 한다.
3. 동일한 릴리스로 추적 관리되어야 한다.
4. 동일한 릴리스 문서에 포함되어야 한다.
   <br />
   <br />

## 💡<strong>CCP: 공통 폐쇄 원칙</strong>

👉 CCP는 <strong>"컴포넌트 수준"</strong>의 SRP: 단일 책임 원칙이다.
<br />
<br />
SRP에서 `단일 클래스`는 변경의 이유가 여러 개 있어서는 안된다고 말하듯이,<br />
CCP에서도 `단일 컴포넌트`는 변경의 이유가 여러 개 있어서는 안된다.
<br />
<br />
애플리케이션에서 코드가 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기 보다는,
차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.
만약 변경을 단일 컴포넌트로 제한할 수 잇다면, 해당 컴포넌트만 재배포하면 된다.
<br />
<br />
CCP는 같은 이유로 변경될 가능성이 있는 클래스들은 하나의 컴포넌트에 속해야 한다.
이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화 할 수 있다.
<br />
<br />

### 🚩 SRP와의 유사성

SRP에서는 서로 다른 이유로 변경되는 "메서드"를 서로 다른 "클래스"로 분리.<br />
CCP에서는 서로 다른 이유로 변경되는 "클래스"를 서로 다른 "컴포넌트"로 분리.<br />
👉 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라.<br />
👉 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.
<br />
<br />

## 💡<strong>CRP: 공통 재사용 원칙</strong>

👉 CRP는 ISP: 인터페이스 분리 원칙의 포괄적인 버전이다.
<br />
<br />
`같이 재사용되는 경향이 있는 클래스와 모듈`들은 `같은 컴포넌트에 포함`해야 한다.<br />
개별 클래스가 단독으로 재사용되는 경우는 거의 없으며, 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용 하는 경우가 많다.<br />
CRP에서는 이런 클래스들이 `동일한 컴포넌트에 포함되어야 한다`고 말한다.
<br />
<br />
CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스도 말해준다.<br />
어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다.<br />
사용하는(using) 컴포넌트가 사용되는(used) 컴포넌트에서 단 하나의 클래스만 사용했을 경우,
단 하나만 사용한다고 해서 의존성은 조금도 약해지지 않고 사용하는 컴포넌트는 사용되는 컴포넌트에 여전히 의존한다.
<br />
<br />
이같은 의존성으로 인해 사용되는 컴포넌트가 변경될 때마다 사용하는 컴포넌트도 변경해야 할 가능성이 높다. 심지어 발생한 변경이 사용하는 컴포넌트와는 전혀 관련 없는 경우에도 말이다.
<br />
<br />
`따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.`<br /> 즉, `일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음`을 확실히 인지해야 한다.
그렇지 않으면 필요 이상으로 많은 컴포넌트를 재배포하느라 허비하게 된다.
<br />
<br />

### 🚩 ISP와의 관계

ISP는 사용하지 않은 "메서드"가 있는 "클래스"에 의존하지 말라.<br />
CRP는 사용하지 않는 "클래스"를 가진 "컴포넌트"에 의존하지 말라.<br />
👉 <strong>필요하지 않은 것에 의존하지 말라.</strong>

### 👉 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다.

<br />
<br />

## 💡<strong>결론</strong>

REP와 CCP는 컴포넌트를 더욱 크게 만드는 "포함 원칙"이고,<br />
CRP는 컴포넌트를 더욱 작게 만드는 "배제 원칙"이다.
<br />
<br />
프로젝트 초기에는 CCP가 REP보다 훨씬 중요한데, 개발 가능성이 재사용성보다 더욱 중요하기 때문이다. 즉, 프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.
<br />
<br />
어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다. 이 균형점은 항상 유동적이다.
<br />
<br />
시간이 흐름에 따라 프로젝트의 초점이 `개발가능성 -> 재사용성`으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 진화한다.
