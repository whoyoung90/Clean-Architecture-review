# 9장 LSP: 리스코프 치환 원칙

### SOLID 원칙 중, "LSP: 리스코프 치환 원칙"이란?

<br />
<strong>Liskov Substitution Principle</strong>
<br />

👉 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, `이들 구성요소는 반드시 서로 치환 가능`해야 한다.<br />
👉 `하위 타입`으로 적합하기 위해서는 `상호 치환 가능`해야 한다!
<br />
<br />

## 💡<strong>하위 타입(subType)의 정의</strong>

S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고,<br />
T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도<br />
P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
<br />
<br />
설계가 LSP를 준수한다면, 애플리케이션의 행위가 "인터페이스의 하위 타입"중 무엇을 사용하는지에 전혀 의존하지 않게 된다.<br />
이들 하위 타입은 모두 `인터페이스 타입을 치환할 수 있다.`
<br />
<br />

## 💡<strong>LSP 위배 사례</strong>

"정사각형/직사각형 문제" 등과 같이 <strong>예외 사항을 처리하는 로직</strong>이 추가되어야 할 때는<br />
또 다른 if문을 추가하기 보단, 이 같은 버그로 부터 `시스템을 격리`해야 한다.
<br />
<br />
또한 아키텍트는 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야 한다.
<br />
<br />

## 💡<strong>결론</strong>

LSP는 아키텍쳐 수준까지 확장해야만 한다.
치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.
