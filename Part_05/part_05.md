# 5장 객체지향 프로그래밍

데이터와 함수의 조합?<br />
캡슐화 (encapsulation), 상속 (inheritance), 다형성 (polymorphism)
<br />
<br />

## 💡<strong>캡슐화</strong>

캡슐화를 통해 데이터와 함수가 응집력 있게 구성된 집단을 `서로 구분 짓는 선`을 그을 수 있다.<br />

- 구분선 바깥에서 데이터는 은닉되고 `(private 멤버 데이터)`
- 일부 함수만이 외부에 노출된다 `(public 멤버 함수)`
  <br />
  <br />

### 🚩 C 언어에서의 캡슐화

C 프로그래머는 먼저 데이터 구조와 함수를 헤더 파일에 선언하고, 구현 파일에서 이들을 구현했다.<br />
그리고 프로그램 사용자는 `함수를 호출할 수는 있지만`, 데이터 구조와 함수가 어떻게 구현되었는지에 대해서는(구현 파일에 작성된 항목에 대헤서는) `어떠한 방법으로도 접근할 수 없었다.`
<br />
<br />

### 🚩 캡슐화의 약화

C++은 `컴파일러가 클래스의 인스턴스 크기를 알 수 있어야 한다`는 기술적인 이유로, 클래스의 멤버 변수를 해당 클래스의 헤더 파일에 선언할 것을 요구했다.<br />
물론 멤버 변수에 접근하는 일은 컴파일러가 막겠지만, <strong>사용자는 멤버 변수가 존재한다는 사실 자체를 알게 되며 캡슐화가 깨지게 된다.</strong>
<br />
<br />

언어에 `public, private, protected` 키워드를 도입함으로써 불완전한 캡슐화를 사실상 보완하기는 하였지만,<br />
이는 컴파일러가 헤더 파일에서 멤버 변수를 볼 수 있어야 했기 때문에 조치한 임시방편일 뿐이다.
<br />
<br />

실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다. (자바스크립트, 파이썬 등등)<br />
OO를 제공한다고 주창한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.

### 👉 C언어에서의 완벽한 '캡슐화'가 기술적인 이유로 다른 언어들에서 약화되었다.

### 👉 내가 알고있던 캡슐화를 역사의 흐름으로 듣는 기분..!

<br />
<br />

## 💡<strong>상속</strong>

어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일<br />
데이터 구조에 가면을 씌우는 일<br />
OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, <strong>상속만큼은 OO 언어가 확실히 제공했다.</strong>
<br />
<br />

## 💡<strong>다형성</strong>

플러그인 아키텍처는 `"장치 독립성"`을 지원하기 위해 만들어졌고,<br />
OO의 등작으로 언제 어디서든 `플러그인 아키텍처`를 적용할 수 있게 되었다.
<br />
<br />

OO 언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소스 코드 `의존성을 어디에서든 역전(dependency inversion)`시킬수 있다는 뜻이다.<br />
소스 코드 의존성은 소스 코드 사이에 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.
<br />
<br />

OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 `시스템의 소스 코드 의존성 전부에 대해 방향을 결정`할 수 있는 절대적인 권한을 갖는다.<br />
즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.<br />
호출하는 모듈이든, 호출 받는 모듈이든 관계없이 `소스 코드 의존성을 원하는 방향으로 설정할 수 있다.`
<br />
<br />

### 🚩 배포 독립성 (independent deployability)

특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다.

### 🚩 개발 독립성 (independent developability)

시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다.
<br />
<br />

## 💡<strong>결론</strong>

OO란 `"다형성"`을 이용하여 전체 시스템의 `모든 소스 코드 의존성에 대한 절대적인 제어 권한`을 획득할 수 있는 능력이다.
<br />
<br />

OO를 사용하면 아키텍트는 `플러그인 아키텍처`를 구성할 수 있고,<br />
고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 `"독립성"`을 보장할 수 있다.
<br />
<br />

저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 `"독립적"`으로 개발하고 배포할 수 있다.
