# 8장 OCP: 개방-폐쇄 원칙

### SOLID 원칙 중, "OCP: 개방-폐쇄 원칙"이란?

<br />
<strong>Open-Closed Principle</strong>
<br />

👉 기존 코드를 수정하기보다는 반드시 `새로운 코드를 추가하는 방식으로` 시스템 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.<br />
👉 소프트웨어 개체의 행위는 `확장할 수 있어야 하지만, 이때 개체를 변경해서는 안된다.`
<br />
<br />
요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면.. 엄청난 실패!!
<br />
<br />

## 💡<strong>변경량을 최소화 하려면?</strong>

1. 서로 다른 목적으로 변경되는 요소를 적절하게 분리 `(단일 책임 원칙 SRP)`

2. 이들 요소 사이의 의존성을 체계화 `(의존성 역전 원칙 DIP)`<br />
   (두 책임 중 하나에서 변경이 발생하더라도 다른 하나는 변경되지 않도록)<br />
   (새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않도록)
   <br />
   <br />

## 💡<strong>사고 실험</strong>

### 🚩 모든 의존성은 소스 코드 의존성을 나타낸다.

<strong>`A클래스 -> B클래스`</strong><br />
A클래스에서는 B클래스를 호출하지만, B클래스에서는 A클래스를 전혀 호출하지 않음을 뜻한다.<br />
즉, A클래스는 구현관계를 통해 B클래스를 알고 있지만, B클래스는 A클래스에 대해 아무것도 알지 못한다.
<br />
<br />

### 🚩 모든 컴포넌트 관계는 "단방향"으로만 이루어진다.

화살표는 <strong>"변경으로부터 보호하려는 컴포넌트를 향하도록"</strong> 그려진다.
<br />

<strong>`A컴포넌트 -> B컴포넌트`</strong><br />
A컴포넌트에서 발생한 변경으로부터 `B컴포넌트를 보호`하려면 반드시 A컴포넌트가 B컴포넌트에 의존해야 한다.
<br />
<br />

### 🚩 아키텍쳐 수준에서 OCP가 동작하는 방식

<strong>`A -> B -> C`</strong><br />
보호의 계층구조는 "수준(level)"이라는 개념을 바탕으로 생성된다.
C는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다.
A는 가장 낮은 수준의 개념이며, 따라서 거의 보호를 받지 못한다.

이것이 아키텍쳐 수준에서 OCP가 동작하는 방식이다.
<br />
<br />
아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트 계층구조로 조직화한다.
<br />
<br />
컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.
<br />
<br />

## 💡<strong>방향성 제어</strong>

<strong>`A컴포넌트 -> B인터페이스 <- C컴포넌트`</strong><br />
B인터페이스는 A와 C 사이에 위치하는데, 이는 `"의존성을 역전"`시키기 위해서다.<br />
B인터페이스가 없었다면, 의존성이 A컴포넌트에서 C컴포넌트로 바로 향하게 된다.

## 💡<strong>정보 은닉</strong>

<strong>`A -> B인터페이스 <- C`</strong><br />
B인터페이스가 방향성 제어와는 다르게, `A가 C 내부에 대해 너무 많이 알지 못하도록` 막기 위해 존재할 수도 있다!
<br />
<br />
B인터페이스가 없었다면, A는 C에 대해 "추이 종속성"을 가지게 되며,<br />
'자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다'는 소프트웨어 원칙을 위반하게 된다.
<br />
<br />
A에서 발생한 변경으로부터 C를 보호하려는 일의 우선순위가 가장 높지만,<br />
반대로 C에서 발생한 변경으로부터 A도 보호되기를 바란다. 이를 위해 C의 내부를 은닉한다.
<br />
<br />

## 💡<strong>OCP 목표</strong>

시스템을 확장하기 쉬운 동시에, 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데에 있다.
<br />
<br />
이러한 목표를 달성하려면<br />

1. 시스템을 컴포넌트 단위로 분리하고
2. 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 "의존성 계층구조"를 만들어야 한다!
