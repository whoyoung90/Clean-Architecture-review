# 14장 컴포넌트 결합

## 💡<strong>ADP: 의존성 비순환 원칙</strong>

### 🚩 순환 의존성 제거하기

개발 환경을 "릴리스 가능한 컴포넌트 단위"로 분리한다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
<br />
<br />
특정 컴포넌트가 변경되더라도 다른 팀에 "즉각" 영향을 주지는 않고, 각 팀은 특정 컴포넌트가 새롭게 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.
<br />
<br />
성공적으로 동작하려면 컴포넌트 사잉의 의존성 구조를 반드시 관리해야 한다.
<br />
<br />
의존성 구조에 순환이 있어서는 안된다. 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 `최초의 컴포넌트로 되돌아 갈 수 없어야 한다. 즉, 순환이 없어야 한다.`
<br />
<br />

### 🚩 순환이 컴포넌트 의존성 그래프에 미치는 영향

순환 의존성이 발생하면 해당 컴포넌트의 개발자들은 모두 서로에게 얽매이게 되는데,
모두 항상 정확하게 동일한 릴리스를 사용해야 하기 때문이다.
<br />
<br />
의존성 그래프에 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워지고, 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
<br />
<br />

### 🚩 순환 끊기

1. `인터페이스`나 `추상 클래스` 같은 추상적인 선언을 통해 `의존성 역전 원칙(DIP)`을 적용한다.
2. 순환하지 않도록 모두 의존하는 `새로운 컴포넌트`를 만든다.

애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다. 따라서 의존성 구조에 순환이 발생하는지 항상 관찰해야 한다. `순환이 발생하면 어떤 식으로든 끊어야 한다.`
<br />
<br />

## 💡<strong>SDP: 안정된 의존성 원칙</strong>

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 안된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.
<br />
<br />
모듈을 만들때 변경하기 쉽도록 설계했더라도, 누군가가 의존성을 매달아 버리면 모듈을 변경하기 어려워진다. 당신의 모듈에서는 단 한줄의 코드도 변경되지 않았지만, 어느 순간 갑자기 당신의 모듈을 변경하는 일이 상당히 도전적인 일이 된다.
<br />
<br />
변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 `안정된 의존성 원칙`을 준수해야 한다!
<br />
<br />

### 🚩 안정성이란?

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
<br />
<br />
컴포너트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적!<br />
사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.
<br />
<br />
👉 <strong>최고 안정성</strong><br />

- 세 컴포넌트가 X에 의존하기 때문에, X 컴포넌트는 변경하지 말아야 할 이유가 세 가지가 된다.
- 컴포넌트X에 의존하는 다른 컴포넌트가 있지만, 다른 컴포넌트에 의존하지 않는다.
- 자신에게 의존하는 컴포넌트가 있으므로 해당 컴포넌트는 변경하지 어렵지만, 해당 컴포넌트를 변경하도록 강제하는 의존성은 갖지 않는다.

```bash
->
->  X
->
```

<br />
👉 <strong>최고 불안정성</strong><br />

- 어떤 컴포넌트도 컴포넌트Y에 의존하지 않지만, 컴포넌트Y는 다른 컴포넌트에 의존하는 경우.
- 자신에게 의존하는 컴포넌트가 없으므로, 이 컴포넌트는 변경하지 말아야 할 이유가 없다.
- 반대로 이 컴포넌트가 다른 컴포넌트에 의존한다는 사실은 언젠가 해당 컴포넌트를 변경해야 할 이유가 있다는 뜻이다.

```bash
   ->
Y  ->
   ->
```

<br />

### 🚩 예시

Stable 컴포넌트에서 작업하던 개발자가 Flexible 컴포넌트에 의존성을 걸게 되었다.
이로 인해 SDP를 위배하고, 결국 Flexible은 변경하기 어렵게 된다.
<br />
<br />
이 문제를 해결하려면 Stable의 Flexible에 대한 의존성을 끊어야 한다.
<br />
<br />
`추상 인터페이스`를 생성하는 방식으로 `DIP`를 도입하면 이 문제를 해결할 수 있다.<br />
이를 통해 Stable의 Flexible에 대한 의존성을 끊을 수 있고, 두 컴포넌트 모두 추상 인터페이스에 의존하도록 강제한다.
<br />

```bash
Stable → "추상 인터페이스"
             ↑
          Flexible
```

<br />

## 💡<strong>SAP: 안정된 추상화 원칙</strong>

안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다.
<br />
<br />
`고수준 정책`을 캡슐화하는 소프트웨어는 반드시 `안정된 컴포넌트`에 위치해야 한다.<br />
불안정한 컴포넌트는 쉽고 빠르게 변경할 수 있는 변동성이 큰 소프트웨어만을 포함해야 한다.
<br />
<br />
`안정된 컴포넌트`는 `추상 컴포넌트`여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다.<br />
불안정한 컴포넌트는 구체 컴포넌트여야 하며, 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 한다.
<br />
<br />
<strong>`안정적인 컴포넌트`라면 반드시 `인터페이스`와 `추상 클래스`로 구성되어 쉽게 확장할 수 있어야 한다.</strong>

### 👉 의존성은 추상화의 방향으로 향하게 된다!
