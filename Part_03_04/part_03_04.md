# 3장 패러다임 개요

패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
<br />
<br />
각 패러다임은 프로그래머에게서 권한을 박탈한다.<br />
패러다임은 무엇을 해야 할지를 말하기보다는 `무엇을 해서는 안 되는지`를 말해준다.
<br />
<br />

1. 구조적 프로그래밍<br />
   제어흐름의 `직접적인 전환에 대해` 규칙을 부과

2. 객체지향 프로그래밍<br />
   제어흐름의 `간적접인 전환에 대해` 규칙을 부과

3. 함수형 프로그래밍<br />
   `할당문에 대해` 규칙을 부과
   <br />
   <br />

# 4장 구조적 프로그래밍

## 💡<strong>기능적 분해</strong>

모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.<br />
이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있다.
<br />
<br />

## 💡<strong>수학이 아닌 과학이 구출하다</strong>

과학은 언젠가는 다른 실험을 통해 잘못되었음이 밝혀질 가능성이 항상 열려있다.<br />
과학은 서술된 내용이 사실임을 증명하는 방식이 아니라, <strong>`서술이 틀렸음을 증명하는 방식으로 동작한다.`</strong>
<br />
<br />

## 💡<strong>테스트</strong>

"테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"
<br />
<br />
프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.<br />
테스트가 보장할 수 있는 것은 프로그램이 목표에 부합할 만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.
<br />
<br />
소프트웨어는 수학이 아닌 `과학`과 같다.<br />
최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.
<br />
<br />
구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.<br />
테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.
<br />
<br />
`거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여길 수 있다.`
<br />
<br />
소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.<br />
소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.

### 👉 부정확함에 대한 증명!
